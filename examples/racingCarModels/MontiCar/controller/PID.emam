package controller;

component PID(Z(0:1:2) PIDIndex ){
	ports 
		in Q( -oo : 0.001 : oo) error;
		in PIDTuple tuple;
		
		out Q( -oo : 0.0001 : oo) output;
		
		static Z(0:1:oo) time_prev = 1;
		static Q(-oo :0.001 : oo) int_error = 1;
		static windup_guard = 10;
		static prev_error = 0;
		
	implementation Math{
		
		Z(0:1:oo) time_now = now();
		Z(1: 1 : oo) time_diff = time_now - time_prev;
		
		int_error = int_error * time_diff;
		
		if (int_error > windup_guard) {
			int_error = windup_guard;		
		}elseif (int_error < -windup_guard){
			int_error = -windup_guard;
		}
		
		if(PIDIndex == 0){		
			Q(-oo: 0.001 :oo) P_term = tuple.steerP * error;
			Q(-oo: 0.001 :oo) I_term = tuple.steerI * pid.int_error;
			Q(-oo: 0.001 :oo) D_term = tuple.steerD * ((error - prev_error) / time_diff);
		}
		if(PIDIndex == 1){		
			Q(-oo: 0.001 :oo) P_term = tuple.speedP * error;
			Q(-oo: 0.001 :oo) I_term = tuple.speedI * pid.int_error;
			Q(-oo: 0.001 :oo) D_term = tuple.speedD * ((error - prev_error) / time_diff);
		}
		if(PIDIndex == 2){		
			Q(-oo: 0.001 :oo) P_term = tuple.accelP * error;
			Q(-oo: 0.001 :oo) I_term = tuple.accelI * int_error;
			Q(-oo: 0.001 :oo) D_term = tuple.accelD * ((error - prev_error) / time_diff);
		}
		
		time_prev = time_now;
		prev_error = error;
		
		
		output = P_term + I_term + D_term;
		
	}
}